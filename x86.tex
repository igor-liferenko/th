\hsize=210mm \advance\hsize by-3cm
\vsize=297mm \advance\vsize by-4cm
\input docmy.tex
\hoffset=1.5cm \advance\hoffset by-1in
\voffset=1.5cm \advance\voffset by-1in
\newcount\n
\def\N{\advance\n by1\indent\hbox to0pt{\hskip-\parindent\bf\the\n.\hfil}}
\parindent=15pt

\title Openwrt for x86

\centerline{\eightit(this virtual machine has been done specially for testing triggerhappy)}
\bigskip

\N
Build virtual machine:
\begtt
./build-x86.sh
\endtt
\medskip

\N
Plug in usb keyboard or numpad (in addition to your main keyboard), see dmesg for {\sl vendorid\/} and {\sl productid\/}
values, and start qemu:
\begtt
make boot
\endtt
\medskip

If usb will not work, search such lines in qemu output:
\begtt
libusb: error [_get_usbfs_fd] libusb couldn't open USB device /dev/bus/usb/006/002: Permission denied
libusb: error [_get_usbfs_fd] libusb requires write access to USB device nodes.
\endtt
\smallskip
Then {\tt poweroff} qemu and do this:
\begtt
sudo chgrp dialout /dev/bus/usb/006/002
\endtt
\medskip

\N
Build triggerhappy (see README how to run it):
\begtt
make
\endtt
\medskip

\noindent "conf/triggers.d/example.conf":
\smallskip
\listing{conf/triggers.d/example.conf}
\medskip
\noindent "conf/sleep0":
\smallskip
\listing{conf/sleep0}
\medskip
\noindent "conf/sleep0-release":
\smallskip
\listing{conf/sleep0-release}
\medskip
\noindent "conf/sleep1":
\smallskip
\listing{conf/sleep1}
\medskip
\noindent "conf/sleep1-release":
\smallskip
\listing{conf/sleep1-release}
\medskip
\noindent "conf/sleep2":
\smallskip
\listing{conf/sleep2}
\medskip
\noindent "conf/sleep2-release":
\smallskip
\listing{conf/sleep2-release}

\vfill\eject
\noindent{\bf History:}
At first I used this configuration:
\begtt
KEY_KPPLUS 1 /etc/triggerhappy/volume_plus
KEY_KPPLUS 2 /etc/triggerhappy/volume_plus
\endtt
where "volume_plus" is "mpc -q -h `cat /etc/ip` volume +1".

Testing this exhibited the problem: when the required volume level was
reached, I released the button, but the volume continued to grow higher
and higher. I think this was because a queue of mpc calls was created
which continued to change volume after button was released, because the
requests were too fast and mpc call did not have time to finish before
another mpc request arrived.

Then I decided to check if "mpc" was already runnig before calling "mpc"
again, by putting this line before "mpc" call in "volume_plus":
"ps | grep -q [m]pc && exit". This did not work either. The result was
the same. IIRC, it was due to the fact that mpc command just queued the
command and exited - not waiting until it fully completes. So, effect
was the same as before.

Then I decided to use mutexes and delay for volume buttons.
The mutex garanteed that no other instance of "volume_plus" is running.
And delay guaranteed that the operation will have time to finish before
another one is started. So, the "grep" call above was changed into \par
"mkdir /var/lock/volume 2>/dev/null || exit <mpc> <delay>
rmdir /var/lock/volume" \par\noindent But this did not work either - holding the
volume button rebooted the router. Do not know why, but probably because
a lot of instances of script was started by {\sl triggerhappy\/}, which
caused memory exhaustion on dir320.

Then I thought: ``hey, what if we use the delay and just keep executing
"mpc" in the loop until button is released!'' This was exactly what
was needed! So, I changed "volume_plus" into "while [ 1 ]; do <mpc>
<delay> done" and added "volume_plus-release", which was just supposed
to kill "volume_plus". {\sl triggerhappy\/} config was changed like this:
\begtt
 KEY_KPPLUS 1 /etc/triggerhappy/volume_plus
-KEY_KPPLUS 2 /etc/triggerhappy/volume_plus
+KEY_KPPLUS 0 /etc/triggerhappy/volume_plus-release
\endtt

Problems persisted even here---sometimes when the button is released,
the volume continues to grow, but not depending on how long you kept
volume button pressed - it just grows and grows until you tap the
volume button once again - then it stops. I'm also puzzled by strange
ouput from ps command when button is pressed, hold and released.
The testing results in `case 2' below are for this configuration.

\noindent{\bf What we need to achieve:}
{\sl triggerhappy\/} must not wait until the script started by it finishes.
In terms of testing results below (output from
"while true; do ps -w|grep [s]leep; done"), script from `case 2' must behave
the same as script from `case 0', except
that in ``Hold'' phase must be this
(this is what happens when "/etc/triggerhappy/sleep2 &" is run separately):
\begtt
 1321 root      9292 R    {sleep2} /bin/sh /etc/triggerhappy/sleep2
 1321 root      9292 R    {sleep2} /bin/sh /etc/triggerhappy/sleep2
 1321 root      9292 R    {sleep2} /bin/sh /etc/triggerhappy/sleep2
 1321 root      9292 R    {sleep2} /bin/sh /etc/triggerhappy/sleep2
...
\endtt
\medskip
\noindent{\bf Case 0:}
Hold "KEY_KPPLUS"
button pressed - nothing will appear in "ps" (this is how it should be).
The problem is that the moment when the button is pressed and the
moment when it is released there appear lines with "S" and "R" in
"ps" output. What is "R"?

\indent\hbox to0pt{\hskip-\parindent$\bullet$\hfil}%
Press:
\begtt
28886 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep0
28889 root      9292 R    /bin/sh -c /etc/triggerhappy/sleep0
\endtt

\indent\hbox to0pt{\hskip-\parindent$\bullet$\hfil}%
Hold: nothing happens

\indent\hbox to0pt{\hskip-\parindent$\bullet$\hfil}%
Release:
\begtt
10845 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep0-release
10846 root      9292 S    {sleep0-release} /bin/sh /etc/triggerhappy/sleep0-release
10849 root      9292 R    {sleep0-release} /bin/sh /etc/triggerhappy/sleep0-release
\endtt
\medskip
\noindent{\bf Case 1:}
Hold "KEY_KPASTERISK"
button pressed.
This is what happens:

\indent\hbox to0pt{\hskip-\parindent$\bullet$\hfil}%
Press:
\begtt
11989 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep1
11992 root      9292 R    /bin/sh -c /etc/triggerhappy/sleep1
11989 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep1
\endtt

\vfill\eject
\indent\hbox to0pt{\hskip-\parindent$\bullet$\hfil}%
Hold:
\begtt
11992 root      9292 S    {sleep1} /bin/sh /etc/triggerhappy/sleep1
11993 root      9284 S    sleep 1
11989 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep1
11992 root      9292 S    {sleep1} /bin/sh /etc/triggerhappy/sleep1
11993 root      9284 S    sleep 1
11989 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep1
<repeats continuously very fast>
\endtt

\indent\hbox to0pt{\hskip-\parindent$\bullet$\hfil}%
Release:
\begtt
15375 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep1-release
15376 root      9292 S    {sleep1-release} /bin/sh /etc/triggerhappy/sleep1-release
15379 root      9292 R    {sleep1-release} /bin/sh /etc/triggerhappy/sleep1-release
\endtt
\medskip
\noindent{\bf Case 2:}
Hold "KEY_KPENTER"
button pressed.
The (main) problem is this: if the script does not exit immediately
after executing "echo sleep", but stays to work forever in a loop
(e.g., "while true; do echo sleep; done"),
then when I hold the button pressed, in "ps" there are a lot of calls of
"sleep2" script, and appear "R",
as well as "S". And in this case "sleep" also does not appear in "ps"
output (why?).

\indent\hbox to0pt{\hskip-\parindent$\bullet$\hfil}%
Press:
\begtt
32612 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep2
32615 root      9292 R    /bin/sh -c /etc/triggerhappy/sleep2
32612 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep2
\endtt

\indent\hbox to0pt{\hskip-\parindent$\bullet$\hfil}%
Hold:
\begtt
32615 root      9292 R    {sleep2} /bin/sh /etc/triggerhappy/sleep2
32612 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep2
32615 root      9292 R    {sleep2} /bin/sh /etc/triggerhappy/sleep2
32612 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep2
32615 root      9292 R    {sleep2} /bin/sh /etc/triggerhappy/sleep2
32612 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep2
<repeats continuously very fast>
\endtt

\indent\hbox to0pt{\hskip-\parindent$\bullet$\hfil}%
Release:
\begtt
  488 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep2-release
  491 root      9292 R    /bin/sh -c /etc/triggerhappy/sleep2-release
32612 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep2
32615 root      9292 R    {sleep2} /bin/sh /etc/triggerhappy/sleep2
  488 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep2-release
  491 root      9292 S    {sleep2-release} /bin/sh /etc/triggerhappy/sleep2-release
  494 root      9292 R    {sleep2-release} /bin/sh /etc/triggerhappy/sleep2-release
32612 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep2
32615 root      9292 R    {sleep2} /bin/sh /etc/triggerhappy/sleep2
32612 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep2
32615 root      9292 R    {sleep2} /bin/sh /etc/triggerhappy/sleep2
32612 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep2
32615 root      9292 R    {sleep2} /bin/sh /etc/triggerhappy/sleep2
32612 root      9292 S    /bin/sh -c /etc/triggerhappy/sleep2
<repeats forever very fast>
\endtt

\bye
